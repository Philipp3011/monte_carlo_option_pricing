# -*- coding: utf-8 -*-
"""option_pricing

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i7hDJdFtfGhLxmaCR-x1s_q_1qpiKs6P
"""

def brownian_motion(T, n_paths, n_steps, seed):
  if seed is not None:
    np.random.seed(seed)
  dt = T / n_steps
  t = np.linspace(0, T, n_steps + 1)
  dW = np.sqrt(dt) * np.random.normal(size=(n_paths, n_steps))
  W = np.empty((n_paths, n_steps + 1))
  W[:, 0] = 0.0
  W[:, 1:] = np.cumsum(dW, axis=1)
  return t, W

def geometric_brownian_motion(T, n_paths, n_steps, seed, S_0, mu, o):
  t, W = brownian_motion(T, n_paths, n_steps, seed)
  S = np.empty((n_paths, n_steps + 1))
  for i in range(0, n_steps+1):
    S[:, i] = S_0 * np.exp((mu-(1/2)*o**2) * t[i] + o * W[:, i] )
  return S

def price_european_call_monte_carlo(T, n_paths, n_steps, seed, S_0, mu, o, r):
  S = geometric_brownian_motion(T, n_paths, n_steps, seed, S_0, mu, o)
  t = brownian_motion(T, n_paths, n_steps, seed)
  S_T = S[:, -1]
  payoffs = np.maximum(S_T - K, 0)
  discounted_payoffs = np.exp(-r * T) * payoffs
  price = np.mean(discounted_payoffs)
  return price

def price_european_put_monte_carlo(T, n_paths, n_steps, seed, S_0, mu, o, r):
  S = geometric_brownian_motion(T, n_paths, n_steps, seed, S_0, mu, o)
  t = brownian_motion(T, n_paths, n_steps, seed)
  S_T = S[:, -1]
  payoffs = np.maximum(K - S_T, 0)
  discounted_payoffs = np.exp(-r * T) * payoffs
  price = np.mean(discounted_payoffs)
  return price